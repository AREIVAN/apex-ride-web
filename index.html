<!doctype html>
<html lang="es">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>APEX RIDE — Web Prototype</title>

  <!-- Leaflet (Map) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    :root {
      --bg: #070A10;
      --panel: #0B1020;
      --panel2: #0C142A;
      --stroke: rgba(122, 63, 255, .55);
      --neon: #7A3FFF;
      --neon2: #2FE6FF;
      --hot: #FF2E88;
      --text: #EAF0FF;
      --muted: rgba(234, 240, 255, .65);
      --good: #2FE6FF;
      --warn: #FFB020;
      --bad: #FF2E88;
      --r: 16px;
      --shadow: 0 0 24px rgba(122, 63, 255, .18), 0 0 18px rgba(47, 230, 255, .10);
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: var(--text);
      background: radial-gradient(1200px 800px at 15% 20%, rgba(122, 63, 255, .14), transparent 60%),
        radial-gradient(900px 600px at 80% 10%, rgba(47, 230, 255, .12), transparent 55%),
        radial-gradient(1000px 700px at 60% 90%, rgba(255, 46, 136, .10), transparent 55%),
        var(--bg);
    }

    .app {
      display: grid;
      grid-template-columns: 380px 1fr;
      min-height: 100vh;
      gap: 16px;
      padding: 16px;
    }

    @media (max-width: 980px) {
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr
      }
    }

    .panel {
      background: linear-gradient(180deg, rgba(11, 16, 32, .92), rgba(12, 20, 42, .86));
      border: 1px solid rgba(122, 63, 255, .25);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .left {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .topbar {
      padding: 14px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(122, 63, 255, .18);
      background: rgba(6, 10, 18, .55);
    }

    .brand {
      display: flex;
      gap: 10px;
      align-items: center;
      letter-spacing: .12em;
      font-weight: 800;
    }

    .logo {
      width: 34px;
      height: 34px;
      border-radius: 10px;
      background: linear-gradient(135deg, rgba(122, 63, 255, .9), rgba(47, 230, 255, .7));
      box-shadow: 0 0 18px rgba(122, 63, 255, .25), 0 0 12px rgba(47, 230, 255, .18);
      display: grid;
      place-items: center;
      font-weight: 900;
    }

    .chip {
      border: 1px solid rgba(47, 230, 255, .35);
      padding: 6px 10px;
      border-radius: 999px;
      color: var(--neon2);
      font-weight: 700;
      font-size: 12px;
      background: rgba(47, 230, 255, .06);
    }

    .hud {
      padding: 16px;
      display: grid;
      gap: 12px;
    }

    .speedCard {
      padding: 16px;
      border-radius: var(--r);
      border: 1px solid rgba(122, 63, 255, .22);
      background: linear-gradient(180deg, rgba(7, 10, 16, .55), rgba(8, 12, 22, .35));
      position: relative;
      overflow: hidden;
    }

    .speedCard:before {
      content: "";
      position: absolute;
      inset: -2px;
      background: radial-gradient(600px 120px at 20% 10%, rgba(47, 230, 255, .12), transparent 60%),
        radial-gradient(500px 200px at 90% 10%, rgba(122, 63, 255, .16), transparent 55%),
        radial-gradient(700px 200px at 50% 120%, rgba(255, 46, 136, .10), transparent 60%);
      pointer-events: none;
    }

    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      position: relative
    }

    .label {
      font-size: 12px;
      color: var(--muted);
      letter-spacing: .08em;
      text-transform: uppercase
    }

    .valueBig {
      font-size: 64px;
      font-weight: 900;
      line-height: 1;
      letter-spacing: -.02em;
      text-shadow: 0 0 18px rgba(47, 230, 255, .15);
    }

    .unit {
      font-size: 16px;
      font-weight: 800;
      color: var(--muted);
      letter-spacing: .18em;
      margin-left: 8px;
    }

    .kpis {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }

    .kpi {
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(122, 63, 255, .18);
      background: rgba(6, 10, 18, .35);
    }

    .kpi .k {
      font-size: 11px;
      color: var(--muted);
      letter-spacing: .10em;
      text-transform: uppercase
    }

    .kpi .v {
      margin-top: 6px;
      font-size: 16px;
      font-weight: 800
    }

    .actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    button {
      appearance: none;
      border: 1px solid rgba(122, 63, 255, .40);
      background: linear-gradient(180deg, rgba(122, 63, 255, .18), rgba(122, 63, 255, .06));
      color: var(--text);
      padding: 12px 12px;
      border-radius: 14px;
      font-weight: 800;
      cursor: pointer;
      box-shadow: 0 0 18px rgba(122, 63, 255, .12);
      transition: transform .06s ease, border-color .12s ease;
      letter-spacing: .06em;
      text-transform: uppercase;
      font-size: 12px;
    }

    button:hover {
      border-color: rgba(47, 230, 255, .55)
    }

    button:active {
      transform: translateY(1px)
    }

    button.primary {
      border-color: rgba(47, 230, 255, .55);
      background: linear-gradient(180deg, rgba(47, 230, 255, .18), rgba(47, 230, 255, .05));
    }

    button.danger {
      border-color: rgba(255, 46, 136, .60);
      background: linear-gradient(180deg, rgba(255, 46, 136, .18), rgba(255, 46, 136, .05));
    }

    button:disabled {
      opacity: .5;
      cursor: not-allowed
    }

    .statusLine {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      padding: 0 16px 12px 16px;
      color: var(--muted);
      font-size: 12px;
    }

    .pill {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(122, 63, 255, .20);
      background: rgba(6, 10, 18, .35);
    }

    .pill.good {
      border-color: rgba(47, 230, 255, .35);
      color: var(--neon2)
    }

    .pill.bad {
      border-color: rgba(255, 46, 136, .45);
      color: var(--hot)
    }

    .list {
      padding: 14px 16px 16px 16px;
      border-top: 1px solid rgba(122, 63, 255, .18);
      max-height: 380px;
      overflow: auto;
    }

    .list h3 {
      margin: 0 0 10px 0;
      font-size: 12px;
      letter-spacing: .14em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .rideItem {
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(122, 63, 255, .18);
      background: rgba(6, 10, 18, .28);
      display: grid;
      gap: 6px;
      margin-bottom: 10px;
      cursor: pointer;
    }

    .rideItem:hover {
      border-color: rgba(47, 230, 255, .45)
    }

    .rideItem .t {
      font-weight: 900
    }

    .rideItem .m {
      color: var(--muted);
      font-size: 12px
    }

    #map {
      width: 100%;
      height: calc(100vh - 32px);
      min-height: 520px;
      border-radius: var(--r);
      border: 1px solid rgba(122, 63, 255, .25);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .mapWrap {
      position: relative
    }

    .mapOverlay {
      position: absolute;
      top: 14px;
      left: 14px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      z-index: 1000;
    }

    .badge {
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(47, 230, 255, .35);
      background: rgba(6, 10, 18, .55);
      font-size: 12px;
      color: var(--neon2);
      box-shadow: 0 0 14px rgba(47, 230, 255, .10);
      backdrop-filter: blur(6px);
    }

    .smallBtn {
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 11px;
    }

    hr.soft {
      border: none;
      border-top: 1px solid rgba(122, 63, 255, .18);
      margin: 10px 0;
    }
  </style>
</head>

<body>
  <!-- Ride Summary Modal -->
  <div id="rideModal" style="position:fixed; inset:0; display:none; z-index:2000; background:rgba(0,0,0,.55);">
    <div style="
      width:min(560px, calc(100vw - 24px));
      margin:18px auto;
      background:linear-gradient(180deg, rgba(11,16,32,.96), rgba(12,20,42,.92));
      border:1px solid rgba(122,63,255,.25);
      border-radius:16px;
      overflow:hidden;
      box-shadow: 0 0 24px rgba(122,63,255,.18), 0 0 18px rgba(47,230,255,.10);
    ">
      <div
        style="padding:14px 16px; display:flex; justify-content:space-between; align-items:flex-start; border-bottom:1px solid rgba(122,63,255,.18);">
        <div style="min-width:0;">
          <div style="font-size:12px; color:rgba(234,240,255,.65); letter-spacing:.12em; font-weight:800;" id="sumName">
            —</div>
          <div
            style="font-size:22px; font-weight:900; letter-spacing:.02em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"
            id="sumType">RIDE</div>
          <div style="font-size:12px; color:rgba(234,240,255,.65);" id="sumDate">—</div>
        </div>
        <button id="btnCloseRide" class="smallBtn">CLOSE</button>
      </div>

      <div id="sumMap" style="height:240px;"></div>

      <div style="padding:14px 16px; display:grid; grid-template-columns:1fr 1fr; gap:10px;">
        <div class="kpi">
          <div class="k">DISTANCE</div>
          <div class="v" id="sumDist">—</div>
        </div>
        <div class="kpi">
          <div class="k">DURATION</div>
          <div class="v" id="sumDur">—</div>
        </div>
        <div class="kpi">
          <div class="k">AVG SPEED</div>
          <div class="v" id="sumAvg">—</div>
        </div>
        <div class="kpi">
          <div class="k">MAX SPEED</div>
          <div class="v" id="sumMax">—</div>
        </div>
        <div class="kpi">
          <div class="k">AVG PACE</div>
          <div class="v" id="sumPace">—</div>
        </div>
        <div class="kpi">
          <div class="k">POINTS</div>
          <div class="v" id="sumPts">—</div>
        </div>
      </div>
    </div>
  </div>

  <div class="app">
    <div class="left">
      <div class="panel">
        <div class="topbar">
          <div class="brand">
            <div class="logo">A</div>
            <div>
              <div style="font-size:12px; color:var(--muted); letter-spacing:.18em; font-weight:800;">APEX</div>
              <div style="font-size:14px; font-weight:900; letter-spacing:.08em;">RIDE</div>

              <!-- Nuevo: perfil visible -->
              <div style="margin-top:6px; font-size:11px; color:var(--muted); letter-spacing:.06em;">
                <span id="profileName">—</span>
                <span style="opacity:.6;"> • </span>
                <span id="profileVehicle">—</span>
              </div>
            </div>
          </div>
          <div class="chip" id="vehicleChip">MOTO</div>
        </div>

        <div class="hud">
          <div class="speedCard">
            <div class="row" style="margin-bottom:8px;">
              <div class="label">LIVE SPEED</div>
              <div class="label" id="gpsLabel">GPS: —</div>
            </div>
            <div class="row" style="align-items:baseline;">
              <div class="valueBig"><span id="speedNow">0</span><span class="unit">KM/H</span></div>
            </div>
            <div class="row" style="margin-top:10px;">
              <div class="label">MAX</div>
              <div style="font-weight:900;"><span id="speedMax">0</span> <span
                  style="color:var(--muted); font-weight:800;">KM/H</span></div>
            </div>
          </div>

          <div class="kpis">
            <div class="kpi">
              <div class="k">TIME</div>
              <div class="v" id="timeVal">00:00</div>
            </div>
            <div class="kpi">
              <div class="k">DIST</div>
              <div class="v" id="distVal">0.00 km</div>
            </div>
            <div class="kpi">
              <div class="k">AVG</div>
              <div class="v" id="avgVal">0 km/h</div>
            </div>
            <div class="kpi">
              <div class="k">POINTS</div>
              <div class="v" id="ptsVal">0</div>
            </div>
          </div>

          <div class="actions">
            <button class="primary" id="btnStart">START RIDE</button>
            <button class="danger" id="btnStop" disabled>STOP</button>
          </div>
          <div class="actions">
            <button id="btnCenter">CENTER</button>
            <button id="btnClear">CLEAR MAP</button>
          </div>
          <div class="actions">
            <button id="btnProfile">PROFILE</button>
            <button disabled style="opacity:.35;">—</button>
          </div>

          <div class="statusLine">
            <div class="pill good" id="pillStatus">READY</div>
            <div class="pill" id="pillAcc">ACC: —</div>
            <div class="pill" id="pillMode">MODE: WEB DEMO</div>
            <div class="pill" id="pillPlates">PL: —</div>
          </div>

          <div class="list">
            <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
              <button id="tabRides" class="primary" style="flex:1;">RIDES</button>
              <button id="tabSegments" style="flex:1;">SEGMENTS</button>
            </div>

            <div id="panelRides">
              <h3>Rides (local)</h3>
              <div id="ridesList"></div>
            </div>

            <div id="panelSegments" style="display:none;">
              <h3>Segments (local)</h3>

              <div class="actions" style="margin-bottom:10px;">
                <button id="btnCreateSegment" class="primary">CREATE SEGMENT</button>
                <button id="btnCancelSegment">CANCEL</button>
              </div>

              <div style="color:rgba(234,240,255,.65); font-size:12px; margin-bottom:10px;" id="segmentHint">
                Tip: CREATE SEGMENT → click Start en el mapa → click End en el mapa.
              </div>

              <div id="segmentsList"></div>

            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="mapWrap">
      <div id="map"></div>
      <div class="mapOverlay">
        <div class="badge" id="badgeHint">Tip: Usa HTTPS o localhost para GPS.</div>
        <div class="badge" id="badgeRec">REC: OFF</div>
        <div class="badge" id="badgeFollow" style="cursor:pointer;">FOLLOW: OFF</div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    // ---------- Utilities ----------
    function toRad(x) { return x * Math.PI / 180; }
    function haversineMeters(a, b) {
      const R = 6371000;
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lng - a.lng);
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
      const s = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(s));
    }
    function fmtTime(sec) {
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return String(m).padStart(2, '0') + ":" + String(s).padStart(2, '0');
    }
    // Decode polyline (OSRM returns polyline6 by default if requested; we will request geojson to avoid decoding)
    // Distance from point to segment (approx, in meters) using equirectangular projection
    function pointToSegmentDistanceMeters(p, a, b) {
      // project lat/lng to meters around latitude p.lat
      const R = 6371000;
      const lat = toRad(p.lat);
      const x = (lng) => R * toRad(lng) * Math.cos(lat);
      const y = (latd) => R * toRad(latd);

      const px = x(p.lng), py = y(p.lat);
      const ax = x(a.lng), ay = y(a.lat);
      const bx = x(b.lng), by = y(b.lat);

      const abx = bx - ax, aby = by - ay;
      const apx = px - ax, apy = py - ay;

      const ab2 = abx * abx + aby * aby;
      const t = ab2 === 0 ? 0 : clamp((apx * abx + apy * aby) / ab2, 0, 1);
      const cx = ax + t * abx, cy = ay + t * aby;

      const dx = px - cx, dy = py - cy;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function distancePointToPolylineMeters(p, poly) {
      // poly: [{lat,lng}, ...]
      if (!poly || poly.length < 2) return Infinity;
      let best = Infinity;
      for (let i = 0; i < poly.length - 1; i++) {
        const d = pointToSegmentDistanceMeters(p, poly[i], poly[i + 1]);
        if (d < best) best = d;
      }
      return best;
    }

    // OSRM routing (returns geojson line that follows roads)
    async function osrmRoute(start, end) {
      // OSRM expects lon,lat
      const url = `https://router.project-osrm.org/route/v1/driving/${start.lng},${start.lat};${end.lng},${end.lat}?overview=full&geometries=geojson&steps=false`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("OSRM request failed");
      const data = await res.json();
      if (!data.routes || !data.routes.length) throw new Error("No route");
      const route = data.routes[0];
      // GeoJSON coords: [lon,lat]
      const coords = route.geometry.coordinates.map(([lon, lat]) => ({ lat, lng: lon }));
      return { coords, distanceM: route.distance, durationS: route.duration };
    }
    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    //funcion bloquear celular
    let wakeLock = null;

    async function enableWakeLock() {
      try {
        if (!("wakeLock" in navigator)) return false;
        wakeLock = await navigator.wakeLock.request("screen");
        wakeLock.addEventListener("release", () => {
          // opcional: console.log("WakeLock released");
        });
        return true;
      } catch (e) {
        console.warn("WakeLock not available/denied:", e);
        return false;
      }
    }

    async function disableWakeLock() {
      try {
        if (wakeLock) {
          await wakeLock.release();
          wakeLock = null;
        }
      } catch (e) {
        console.warn("WakeLock release failed:", e);
      }
    }


    // ---------- State ----------
    const STORAGE_KEY = "apex_ride_web_rides_v1";
    const SEGMENTS_KEY = "apex_ride_web_segments_v1";
    const PROFILE_KEY = "apex_ride_user_profile_v1";

    let userProfile = loadProfile();
    let rides = loadRides();
    let segments = loadSegments();
    let followMode = false;

    // Nuevo: último fix conocido (para Center fuera de Start Ride)
    let lastFix = null; // { lat, lng, acc, t }

    let activeTab = "rides";

    // Segment creation state
    let creatingSegment = false;
    let createStage = 0; // 0=none, 1=waiting start, 2=waiting end
    let segStart = null;
    let segEnd = null;

    let recording = false;
    let watchId = null;
    let startTs = null;
    let lastPoint = null;
    let points = [];
    let distM = 0;
    let maxKmh = 0;
    let timerId = null;
    let polyline = null;
    let marker = null;

    let segStartMarker = null;
    let segEndMarker = null;

    // --- Speed/GPS filtering ---
    let speedEma = 0;                 // km/h smoothed
    let stationaryStreak = 0;         // consecutive "not moving" fixes
    const ALPHA = 0.25;               // smoothing factor (0.15–0.35)
    const MAX_ACC_M = 40;             // ignore fixes worse than this (25–60)
    const STOP_KMH = 2.0;             // below this, consider stopping
    const STOP_STREAK = 4;            // number of consecutive fixes to force 0
    // --- GPS warm-up (avoid initial jump) ---
    let warmupUntilTs = 0;
    let warmupGood = 0;
    const WARMUP_MS = 4000;   // 3–6s recomendado
    const WARMUP_NEED = 2;    // fixes buenos antes de contar
    const WARMUP_ACC_M = 35;  // requiere accuracy <= esto


    const mockUser = { uid: "local_user", name: "AREIVAN" };

    // ---------- Map ----------
    const map = L.map('map', { zoomControl: true }).setView([19.4326, -99.1332], 12); // CDMX default
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    polyline = L.polyline([], { weight: 4, opacity: 0.95 }).addTo(map);
    let segmentLine = L.polyline([], { weight: 6, opacity: 0.85 }).addTo(map);

    // ---------- UI refs ----------
    const elSpeedNow = document.getElementById("speedNow");
    const elSpeedMax = document.getElementById("speedMax");
    const elTime = document.getElementById("timeVal");
    const elDist = document.getElementById("distVal");
    const elAvg = document.getElementById("avgVal");
    const elPts = document.getElementById("ptsVal");
    const elGps = document.getElementById("gpsLabel");
    const elPill = document.getElementById("pillStatus");
    const elAcc = document.getElementById("pillAcc");
    const elRec = document.getElementById("badgeRec");
    const ridesList = document.getElementById("ridesList");

    const btnStart = document.getElementById("btnStart");
    const btnStop = document.getElementById("btnStop");
    const btnCenter = document.getElementById("btnCenter");
    const btnClear = document.getElementById("btnClear");

    const elProfileName = document.getElementById("profileName");
    const elProfileVehicle = document.getElementById("profileVehicle");
    const elPillPlates = document.getElementById("pillPlates");

    const elFollow = document.getElementById("badgeFollow");

    // Segments UI refs
    const tabRides = document.getElementById("tabRides");
    const tabSegments = document.getElementById("tabSegments");
    const panelRides = document.getElementById("panelRides");
    const panelSegments = document.getElementById("panelSegments");
    const btnCreateSegment = document.getElementById("btnCreateSegment");
    const btnCancelSegment = document.getElementById("btnCancelSegment");
    const segmentHint = document.getElementById("segmentHint");
    const segmentsList = document.getElementById("segmentsList");

    const btnProfile = document.getElementById("btnProfile");

    // ---------- Storage ----------
    function loadRides() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch (e) { return []; }
    }
    function saveRides() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(rides));
    }
    function loadSegments() {
      try {
        const raw = localStorage.getItem(SEGMENTS_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch (e) { return []; }
    }
    function saveSegments() {
      localStorage.setItem(SEGMENTS_KEY, JSON.stringify(segments));
    }

    function loadProfile() {
      try {
        const raw = localStorage.getItem(PROFILE_KEY);
        if (raw) return JSON.parse(raw);
      } catch (e) { }

      // Default profile (si no existe)
      return {
        uid: (crypto.randomUUID ? crypto.randomUUID() : String(Date.now())),
        name: "AREIVAN",
        vehicle: "MOTO",
        plates: "" // opcional
      };
    }

    function saveProfile() {
      localStorage.setItem(PROFILE_KEY, JSON.stringify(userProfile));
    }

    function maskPlates(p) {
      const s = (p || "").trim().toUpperCase();
      if (!s) return "—";
      const last4 = s.replace(/[^A-Z0-9]/g, "").slice(-4);
      return last4 ? `***-${last4}` : "—";
    }

    function applyProfileToUI() {
      // Chip de vehículo
      const chip = document.getElementById("vehicleChip");
      if (chip) chip.textContent = (userProfile.vehicle || "MOTO").toUpperCase();

      // Header: Nombre + Vehículo
      if (elProfileName) elProfileName.textContent = (userProfile.name || "—").toUpperCase();
      if (elProfileVehicle) elProfileVehicle.textContent = (userProfile.vehicle || "MOTO").toUpperCase();

      // Status pill: Placas enmascaradas
      if (elPillPlates) elPillPlates.textContent = "PL: " + maskPlates(userProfile.plates);
    }
    // ---------- Tabs ----------
    function setTab(tab) {
      activeTab = tab;
      if (tab === "rides") {
        panelRides.style.display = "";
        panelSegments.style.display = "none";
        tabRides.classList.add("primary");
        tabSegments.classList.remove("primary");
      } else {
        panelRides.style.display = "none";
        panelSegments.style.display = "";
        tabSegments.classList.add("primary");
        tabRides.classList.remove("primary");
        renderSegments();
      }
    }

    function setMarker(lat, lng) {
      if (!marker) {
        marker = L.circleMarker([lat, lng], {
          radius: 8,
          weight: 2,
          opacity: 0.9,
          fillOpacity: 0.6
        }).addTo(map);
      } else {
        marker.setLatLng([lat, lng]);
      }
    }
    // ---------- Render rides list ----------
    function renderRides() {
      ridesList.innerHTML = "";
      if (!rides.length) {
        ridesList.innerHTML = `<div style="color:rgba(234,240,255,.6); font-size:12px;">No rides yet. Record one.</div>`;
        return;
      }
      rides.slice().reverse().forEach((r) => {
        const div = document.createElement("div");
        div.className = "rideItem";
        div.innerHTML = `
          <div class="t">${new Date(r.startedAt).toLocaleString()}</div>
          <div class="m">Dist: ${(r.distanceM / 1000).toFixed(2)} km • Time: ${fmtTime(r.durationS)} • Max: ${Math.round(r.maxKmh)} km/h</div>
        `;
        div.onclick = () => showRide(r);
        ridesList.appendChild(div);
      });
    }

    function showRide(r) {
      clearMapMarkersOnly();
      const latlngs = r.points.map(p => [p.lat, p.lng]);
      polyline.setLatLngs(latlngs);
      if (latlngs.length) {
        map.fitBounds(polyline.getBounds().pad(0.2));
        setMarker(latlngs[latlngs.length - 1][0], latlngs[latlngs.length - 1][1]);
      }
      openRideSummary(r);
      elSpeedNow.textContent = "0";
      elSpeedMax.textContent = String(Math.round(r.maxKmh));
      elTime.textContent = fmtTime(r.durationS);
      elDist.textContent = (r.distanceM / 1000).toFixed(2) + " km";
      elAvg.textContent = (r.avgKmh).toFixed(0) + " km/h";
      elPts.textContent = String(r.points.length);
      elPill.textContent = "VIEWING";
      elPill.className = "pill good";
      elRec.textContent = "REC: OFF";
    }

    // ---------- Segments ----------
    function renderSegments() {
      segmentsList.innerHTML = "";
      if (!segments.length) {
        segmentsList.innerHTML = `<div style="color:rgba(234,240,255,.6); font-size:12px;">No segments yet. Create one.</div>`;
        return;
      }

      segments.slice().reverse().forEach((s) => {
        const best = (s.attempts && s.attempts.length)
          ? s.attempts.slice().sort((a, b) => a.timeS - b.timeS)[0]
          : null;

        const div = document.createElement("div");
        div.className = "rideItem";
        div.innerHTML = `
          <div class="t">${s.name}</div>
          <div class="m">Radius: ${s.radiusM}m • Attempts: ${(s.attempts?.length || 0)} • PB: ${best ? fmtTime(best.timeS) : "—"}</div>
          <hr class="soft"/>
          <div style="display:flex; gap:8px;">
            <button class="smallBtn" data-act="show">SHOW</button>
            <button class="smallBtn" data-act="lb">LEADERBOARD</button>
            <button class="smallBtn" data-act="del" style="border-color: rgba(255,46,136,.45);">DELETE</button>
          </div>
          <div class="m" style="margin-top:8px; display:none;" data-box="lb"></div>
        `;

        div.querySelector('[data-act="show"]').onclick = () => showSegmentOnMap(s);
        div.querySelector('[data-act="del"]').onclick = () => deleteSegment(s.id);
        div.querySelector('[data-act="lb"]').onclick = () => toggleLeaderboard(div, s);

        segmentsList.appendChild(div);
      });
    }

    function showSegmentOnMap(s) {
      if (s.route && s.route.length) {
        segmentLine.setLatLngs(s.route.map(c => [c.lat, c.lng]));
      } else {
        segmentLine.setLatLngs([]);
      }
      clearMapMarkersOnly();
      segStartMarker = L.circleMarker([s.start.lat, s.start.lng], { radius: 9, weight: 2, fillOpacity: 0.6 }).addTo(map);
      segEndMarker = L.circleMarker([s.end.lat, s.end.lng], { radius: 9, weight: 2, fillOpacity: 0.6 }).addTo(map);

      const latlngs = polyline.getLatLngs();
      const bounds = L.latLngBounds([[s.start.lat, s.start.lng], [s.end.lat, s.end.lng]]);
      if (latlngs.length) {
        bounds.extend(polyline.getBounds());
      }
      map.fitBounds(bounds.pad(0.25));

      elPill.textContent = "SEGMENT";
      elPill.className = "pill good";
    }

    function toggleLeaderboard(container, s) {
      const box = container.querySelector('[data-box="lb"]');
      const open = box.style.display !== "none";
      if (open) {
        box.style.display = "none";
        return;
      }
      const top = (s.attempts || []).slice().sort((a, b) => a.timeS - b.timeS).slice(0, 10);
      if (!top.length) {
        box.innerHTML = `<div style="color:rgba(234,240,255,.6); font-size:12px;">No attempts yet.</div>`;
      } else {
        box.innerHTML = top.map((a, i) => (
          `<div style="display:flex; justify-content:space-between; font-size:12px; margin:4px 0;">
            <div>${i + 1}. ${a.name}</div>
            <div style="font-weight:900;">${fmtTime(a.timeS)}</div>
          </div>`
        )).join("");
      }
      box.style.display = "";
    }

    function deleteSegment(id) {
      segments = segments.filter(s => s.id !== id);
      saveSegments();
      renderSegments();
    }

    function clearMapMarkersOnly() {
      if (segStartMarker) { map.removeLayer(segStartMarker); segStartMarker = null; }
      if (segEndMarker) { map.removeLayer(segEndMarker); segEndMarker = null; }
    }

    // Detect segment attempts when a ride is saved
    function detectAttemptsForRide(ride) {
      if (!segments.length || !ride.points || ride.points.length < 2) return;

      for (const s of segments) {
        const r = s.radiusM ?? 25;

        // Need a street route polyline to validate
        if (!s.route || s.route.length < 2) continue;

        // 1) Find first point near start
        let startIdx = -1;
        for (let i = 0; i < ride.points.length; i++) {
          const p = ride.points[i];
          const dStart = haversineMeters({ lat: p.lat, lng: p.lng }, { lat: s.start.lat, lng: s.start.lng });
          if (dStart <= Math.max(40, r * 2)) {
            startIdx = i;
            break;
          }
        }
        if (startIdx < 0) continue;

        // 2) From that point onwards, find end gate
        let endIdx = -1;
        for (let j = startIdx + 1; j < ride.points.length; j++) {
          const p = ride.points[j];
          const dEnd = haversineMeters({ lat: p.lat, lng: p.lng }, { lat: s.end.lat, lng: s.end.lng });
          if (dEnd <= Math.max(40, r * 2)) {
            endIdx = j;
            break;
          }
        }
        if (endIdx < 0) continue;

        // 3) Validate "followed the street route"
        // Compute % of points between startIdx..endIdx that are within r meters of the route polyline
        const window = ride.points.slice(startIdx, endIdx + 1);
        let ok = 0;
        for (const p of window) {
          const d = distancePointToPolylineMeters({ lat: p.lat, lng: p.lng }, s.route);
          if (d <= r) ok++;
        }
        const ratio = ok / Math.max(1, window.length);

        // Require at least 60% on-route for MVP
        if (ratio < 0.60) continue;

        // Attempt time
        const tStart = ride.points[startIdx].t;
        const tEnd = ride.points[endIdx].t;
        const timeS = Math.max(1, Math.round((tEnd - tStart) / 1000));

        const attempt = {
          uid: userProfile.uid,
          name: userProfile.name,
          plates: userProfile.plates, // opcional
          vehicle: userProfile.vehicle, // opcional
          timeS,
          date: Date.now(),
          rideId: ride.id,
          onRoute: Math.round(ratio * 100)
        };

        s.attempts = s.attempts || [];
        if (!s.attempts.some(a => a.rideId === ride.id)) {
          s.attempts.push(attempt);
        }
      }
    }

    // ---------- Recording ----------
    function startRide() {
      if (!navigator.geolocation) {
        alert("Este navegador no soporta geolocalización.");
        return;
      }
      recording = true;
      enableWakeLock();
      setFollow(true);
      points = [];
      distM = 0;
      maxKmh = 0;
      startTs = Date.now();
      // reset filtros
      speedEma = 0;
      stationaryStreak = 0;

      // warm-up
      warmupUntilTs = Date.now() + WARMUP_MS;
      warmupGood = 0;
      lastPoint = null;

      polyline.setLatLngs([]);
      clearMapMarkersOnly();

      elPill.textContent = "RECORDING";
      elPill.className = "pill good";
      elRec.textContent = "REC: ON";

      btnStart.disabled = true;
      btnStop.disabled = false;

      if (timerId) clearInterval(timerId);
      timerId = setInterval(() => {
        if (!recording) return;
        const sec = (Date.now() - startTs) / 1000;
        elTime.textContent = fmtTime(sec);
        elPts.textContent = String(points.length);
        elDist.textContent = (distM / 1000).toFixed(2) + " km";
        const avg = sec > 0 ? (distM / 1000) / (sec / 3600) : 0;
        elAvg.textContent = avg.toFixed(0) + " km/h";
      }, 250);

      watchId = navigator.geolocation.watchPosition(
        onPos,
        (err) => {
          elPill.textContent = "GPS ERROR";
          elPill.className = "pill bad";
          console.error(err);
        },
        { enableHighAccuracy: true, maximumAge: 1000, timeout: 15000 }
      );
    }

    function stopRide() {
      if (!recording) return;
      recording = false;
      disableWakeLock();
      setFollow(false);

      btnStart.disabled = false;
      btnStop.disabled = true;

      elRec.textContent = "REC: OFF";

      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      if (timerId) {
        clearInterval(timerId);
        timerId = null;
      }

      const durationS = Math.max(1, Math.round((Date.now() - startTs) / 1000));
      if (points.length >= 2) {
        const avgKmh = ((distM / 1000) / (durationS / 3600));
        const ride = {
          id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now()),
          startedAt: startTs,
          durationS,
          distanceM: distM,
          maxKmh,
          avgKmh,
          points,
          user: {
            uid: userProfile.uid,
            name: userProfile.name,
            vehicle: userProfile.vehicle,
            plates: userProfile.plates
          }
        };
        rides.push(ride);
        saveRides();
        renderRides();

        // detect segment attempts
        detectAttemptsForRide(ride);
        saveSegments();
        if (activeTab === "segments") renderSegments();

        elPill.textContent = "SAVED";
        elPill.className = "pill good";
      } else {
        elPill.textContent = "NOT SAVED";
        elPill.className = "pill bad";
      }
    }

    function onPos(pos) {
      const c = pos.coords;
      const p = {
        t: Date.now(),
        lat: c.latitude,
        lng: c.longitude,
        acc: c.accuracy ?? null,
        spd: c.speed ?? null // m/s
      };

      // Último fix conocido (Center)
      lastFix = { lat: p.lat, lng: p.lng, acc: p.acc, t: p.t };

      const acc = (typeof p.acc === "number" && !Number.isNaN(p.acc)) ? p.acc : null;
      document.getElementById("pillAcc").textContent = "ACC: " + (acc ? (Math.round(acc) + "m") : "—");
      document.getElementById("gpsLabel").textContent = "GPS: " + (acc ? ("±" + Math.round(acc) + "m") : "—");

      // ---- Warm-up: NO registrar puntos/distancia/velocidad hasta tener GPS estable ----
      const now = Date.now();
      const accOkWarm = (acc !== null && acc <= WARMUP_ACC_M);

      if (recording && (now < warmupUntilTs || warmupGood < WARMUP_NEED)) {
        elPill.textContent = "GPS LOCK…";
        elPill.className = "pill good";

        if (accOkWarm) warmupGood++;

        // mostrar el punto sin registrar el ride
        setMarker(p.lat, p.lng);
        if (followMode) map.panTo([p.lat, p.lng], { animate: false });

        return;
      }

      // A partir de aquí ya registramos
      elPill.textContent = "RECORDING";
      elPill.className = "pill good";

      // --- distancia: filtra por accuracy + movimiento mínimo ---
      const accOk = (acc === null) ? true : (acc <= MAX_ACC_M);
      const minMoveM = acc ? Math.max(6, acc * 0.30) : 6;

      if (lastPoint) {
        const d = haversineMeters({ lat: lastPoint.lat, lng: lastPoint.lng }, { lat: p.lat, lng: p.lng });
        const dt = Math.max(0.5, (p.t - lastPoint.t) / 1000);

        // filtro "teleport": salto irreal -> ignora
        const teleport = (d > 120 && dt < 2);

        if (accOk && !teleport && d >= minMoveM && d < 250) {
          distM += d;
        }
      }

      // Actualiza lastPoint y guarda punto
      lastPoint = p;
      points.push(p);

      // --------- Speed (filtrada) ----------
      let rawKmh = 0;

      if (accOk && typeof p.spd === "number" && !Number.isNaN(p.spd)) {
        rawKmh = p.spd * 3.6;
      } else if (accOk && points.length >= 2) {
        const a = points[points.length - 2];
        const b = points[points.length - 1];
        const dt = Math.max(0.5, (b.t - a.t) / 1000);
        const d = haversineMeters({ lat: a.lat, lng: a.lng }, { lat: b.lat, lng: b.lng });

        // filtro teleport también en velocidad
        if (!(d > 120 && dt < 2)) {
          rawKmh = (d / dt) * 3.6;
        }
      }

      rawKmh = clamp(rawKmh, 0, 320);

      // Stationary detection
      let dLast = 0;
      if (points.length >= 2) {
        const prev = points[points.length - 2];
        dLast = haversineMeters({ lat: prev.lat, lng: prev.lng }, { lat: p.lat, lng: p.lng });
      }

      const looksStopped = accOk && (dLast < minMoveM) && (rawKmh < STOP_KMH);
      if (looksStopped) stationaryStreak++;
      else if (accOk) stationaryStreak = 0;

      // Smooth speed (EMA)
      if (accOk) {
        speedEma = (ALPHA * rawKmh) + ((1 - ALPHA) * speedEma);
      }

      let kmh = speedEma;
      if (stationaryStreak >= STOP_STREAK) kmh = 0;
      if (kmh < 1.2) kmh = 0;
      kmh = clamp(kmh, 0, 320);

      // UI + Max
      elSpeedNow.textContent = String(Math.round(kmh));
      if (kmh > maxKmh) {
        maxKmh = kmh;
        elSpeedMax.textContent = String(Math.round(maxKmh));
      }

      // Dibujar ruta
      polyline.addLatLng([p.lat, p.lng]);
      setMarker(p.lat, p.lng);

      // FOLLOW (aquí sí existe p)
      if (followMode) {
        map.panTo([p.lat, p.lng], { animate: true });
      }
    }

    // ---------- Buttons ----------
    btnStart.onclick = startRide;
    btnStop.onclick = stopRide;
    btnProfile.onclick = () => {
      const name = prompt("Nombre de usuario:", userProfile.name || "") ?? userProfile.name;
      const vehicle = prompt("Vehículo (MOTO/CAR):", userProfile.vehicle || "MOTO") ?? userProfile.vehicle;
      const plates = prompt("Placas (opcional):", userProfile.plates || "") ?? userProfile.plates;

      userProfile.name = String(name).trim() || userProfile.name;
      userProfile.vehicle = String(vehicle).trim().toUpperCase() || "MOTO";
      userProfile.plates = String(plates).trim().toUpperCase();

      saveProfile();
      applyProfileToUI();

      elPill.textContent = "PROFILE SAVED";
      elPill.className = "pill good";
    };

    function setFollow(on) {
      followMode = !!on;
      if (elFollow) elFollow.textContent = "FOLLOW: " + (followMode ? "ON" : "OFF");
    }

    if (elFollow) {
      elFollow.onclick = () => setFollow(!followMode);
    }

    // Si el usuario mueve/zoomea el mapa manualmente, apagamos follow
    map.on("dragstart zoomstart", () => {
      if (followMode) setFollow(false);
    });

    btnCenter.onclick = () => {
      // 1) Si hay una ruta cargada (grabada o ride histórico), centra a esa
      const ll = polyline.getLatLngs();
      if (ll.length) {
        map.fitBounds(polyline.getBounds().pad(0.25));
        return;
      }

      // 2) Si ya tenemos última ubicación conocida, centra ahí
      if (lastFix) {
        map.flyTo([lastFix.lat, lastFix.lng], Math.max(map.getZoom(), 17), { animate: true });
        return;
      }

      // 3) Si no hay nada, pide una lectura puntual
      if (!navigator.geolocation) return;
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const c = pos.coords;
          lastFix = { lat: c.latitude, lng: c.longitude, acc: c.accuracy ?? null, t: Date.now() };
          setMarker(lastFix.lat, lastFix.lng); // opcional: muestra tu punto actual aunque no grabes
          map.flyTo([lastFix.lat, lastFix.lng], Math.max(map.getZoom(), 17), { animate: true });
        },
        (err) => {
          console.error(err);
          elPill.textContent = "GPS DENIED";
          elPill.className = "pill bad";
        },
        { enableHighAccuracy: true, maximumAge: 0, timeout: 15000 }
      );
    };
    btnClear.onclick = () => {
      segmentLine.setLatLngs([]);
      polyline.setLatLngs([]);
      if (marker) { map.removeLayer(marker); marker = null; }
      clearMapMarkersOnly();
      elPill.textContent = "READY";
      elPill.className = "pill good";
      elSpeedNow.textContent = "0";
      elSpeedMax.textContent = "0";
      elTime.textContent = "00:00";
      elDist.textContent = "0.00 km";
      elAvg.textContent = "0 km/h";
      elPts.textContent = "0";
    };

    // ---------- Segment creation ----------
    tabRides.onclick = () => setTab("rides");
    tabSegments.onclick = () => setTab("segments");

    btnCreateSegment.onclick = () => {
      creatingSegment = true;
      createStage = 1;
      segStart = null;
      segEnd = null;
      clearMapMarkersOnly();
      segmentHint.textContent = "Click START point on the map…";
    };

    btnCancelSegment.onclick = () => {
      creatingSegment = false;
      createStage = 0;
      segStart = null;
      segEnd = null;
      clearMapMarkersOnly();
      segmentHint.textContent = "Tip: CREATE SEGMENT → click Start en el mapa → click End en el mapa.";
    };

    map.on("click", async (e) => {
      if (!creatingSegment) return;

      if (createStage === 1) {
        segStart = { lat: e.latlng.lat, lng: e.latlng.lng };
        if (segStartMarker) map.removeLayer(segStartMarker);
        segStartMarker = L.circleMarker([segStart.lat, segStart.lng], { radius: 10, weight: 2, fillOpacity: 0.65 }).addTo(map);
        createStage = 2;
        segmentHint.textContent = "Now click END point on the map…";
        return;
      }

      if (createStage === 2) {
        segEnd = { lat: e.latlng.lat, lng: e.latlng.lng };
        if (segEndMarker) map.removeLayer(segEndMarker);
        segEndMarker = L.circleMarker([segEnd.lat, segEnd.lng], { radius: 10, weight: 2, fillOpacity: 0.65 }).addTo(map);

        try {
          segmentHint.textContent = "Routing via streets… (OSRM)";
          elPill.textContent = "ROUTING…";
          elPill.className = "pill good";

          const name = prompt("Segment name:", "MY STREET SEGMENT") || "MY STREET SEGMENT";
          const radiusM = 25; // tighter now that we have a street polyline

          const routed = await osrmRoute(segStart, segEnd);

          // Draw route line on map
          segmentLine.setLatLngs(routed.coords.map(c => [c.lat, c.lng]));
          map.fitBounds(segmentLine.getBounds().pad(0.25));

          const seg = {
            id: (crypto.randomUUID ? crypto.randomUUID() : String(Date.now())),
            name: name.toUpperCase(),
            vehicleType: "both",
            radiusM,
            start: segStart,
            end: segEnd,
            // Street-following polyline
            route: routed.coords,
            routeDistanceM: routed.distanceM,
            attempts: []
          };

          segments.push(seg);
          saveSegments();
          renderSegments();

          creatingSegment = false;
          createStage = 0;

          segmentHint.textContent = `Segment saved with street route. Dist ${(routed.distanceM / 1000).toFixed(2)} km.`;
          elPill.textContent = "SEGMENT SAVED";
          elPill.className = "pill good";
        } catch (err) {
          console.error(err);
          segmentHint.textContent = "Routing failed. Try another start/end or check connection.";
          elPill.textContent = "ROUTE FAILED";
          elPill.className = "pill bad";
        }
      }
    });

    // ---------- Ride Summary Modal ----------
    let sumMap = null;
    let sumLine = null;

    const rideModal = document.getElementById("rideModal");
    const btnCloseRide = document.getElementById("btnCloseRide");

    btnCloseRide.onclick = () => { rideModal.style.display = "none"; };

    // Cerrar si tocan el fondo oscuro
    rideModal.addEventListener("click", (e) => {
      if (e.target === rideModal) rideModal.style.display = "none";
    });

    function ensureSummaryMap() {
      if (sumMap) return;

      sumMap = L.map("sumMap", {
        zoomControl: false,
        attributionControl: false,
        dragging: false,
        scrollWheelZoom: false,
        doubleClickZoom: false,
        boxZoom: false,
        keyboard: false,
        tap: false
      });

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19 }).addTo(sumMap);
      sumLine = L.polyline([], { weight: 5, opacity: 0.95 }).addTo(sumMap);
    }

    function fmtPaceMinPerKm(durationS, distKm) {
      if (!distKm || distKm <= 0) return "—";
      const pace = durationS / 60 / distKm; // min/km
      const m = Math.floor(pace);
      const s = Math.round((pace - m) * 60);
      return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")} min/km`;
    }

    function openRideSummary(ride) {
      ensureSummaryMap();

      // Header
      document.getElementById("sumName").textContent = (userProfile?.name || "—").toUpperCase();
      document.getElementById("sumType").textContent = (userProfile?.vehicle || "RIDE").toUpperCase();
      document.getElementById("sumDate").textContent = new Date(ride.startedAt).toLocaleString();

      // Metrics
      const distKm = (ride.distanceM / 1000);
      document.getElementById("sumDist").textContent = distKm.toFixed(2) + " km";
      document.getElementById("sumDur").textContent = fmtTime(ride.durationS);
      document.getElementById("sumAvg").textContent = (ride.avgKmh || 0).toFixed(0) + " km/h";
      document.getElementById("sumMax").textContent = Math.round(ride.maxKmh || 0) + " km/h";
      document.getElementById("sumPace").textContent = fmtPaceMinPerKm(ride.durationS, distKm);
      document.getElementById("sumPts").textContent = String(ride.points?.length || 0);

      // Map polyline
      const latlngs = (ride.points || []).map(p => [p.lat, p.lng]);
      sumLine.setLatLngs(latlngs);

      rideModal.style.display = "block";

      // Leaflet: cuando el mapa aparece dentro de un modal, hay que recalcular tamaño
      setTimeout(() => {
        sumMap.invalidateSize(true);
        if (latlngs.length) sumMap.fitBounds(sumLine.getBounds().pad(0.20));
      }, 60);
    }

    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") {
        if (recording) enableWakeLock();
      } else {
        // opcional: no es necesario, pero limpio
        disableWakeLock();
      }
    });
    // ---------- Init ----------
    applyProfileToUI();
    renderRides();
    renderSegments();
    setTab("rides");
  </script>
</body>

</html>